import streamlit as st
import pandas as pd
import io
import json 
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from datetime import datetime, timedelta
import plotly.express as px
import plotly.graph_objects as go
from pathlib import Path
import os

# --- IMPORTS POUR GOOGLE API ---
try:
    from google.oauth2 import service_account
    from googleapiclient.discovery import build
    import gspread
except ImportError:
    st.error("‚ùå Biblioth√®ques Google API manquantes. Ex√©cutez : pip install google-api-python-client google-auth-httplib2 google-auth-oauthlib gspread")
    st.stop()

# --- CONFIGURATION GOOGLE SHEETS ---
GOOGLE_SHEET_URL = "https://docs.google.com/spreadsheets/d/1p8gSC84LZllAaTT6F88xH8nVqZS9jLiOlqiPXHLmJhU/edit"
WORKSHEET_NAME = "HR_Dossiers"

# Configuration de la page
st.set_page_config(
    page_title="Suivi des Dossiers RH - TGCC",
    page_icon="üìã",
    layout="wide",
    initial_sidebar_state="expanded"
)

# CSS personnalis√©
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        font-weight: 600;
        margin-bottom: 1rem;
        color: #1e88e5;
    }
    .metric-card {
        background-color: #f0f2f6;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        margin-bottom: 20px;
    }
    .complete-status {
        background-color: #d4edda;
        color: #155724;
        padding: 5px 10px;
        border-radius: 5px;
        font-weight: bold;
    }
    .incomplete-status {
        background-color: #f8d7da;
        color: #721c24;
        padding: 5px 10px;
        border-radius: 5px;
        font-weight: bold;
    }
    .stTabs [data-baseweb="tab-list"] {
        gap: 10px;
    }
    .stTabs [data-baseweb="tab"] {
        background-color: white;
        border-radius: 4px;
        padding: 10px 16px;
        box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    .stTabs [data-baseweb="tab"][aria-selected="true"] {
        background-color: #e3f2fd;
        border-bottom: 2px solid #1e88e5;
    }
    
    /* Optimisation des tableaux */
    .stDataFrame {
        font-size: 0.85rem;
    }
    .stDataFrame table {
        margin: 0 auto;
        max-width: 95%;
    }
    .stDataFrame th {
        text-align: center !important;
        padding: 8px 4px !important;
        font-size: 0.8rem;
        font-weight: 600;
    }
    .stDataFrame td {
        text-align: center !important;
        padding: 6px 4px !important;
        font-size: 0.8rem;
    }
</style>
""", unsafe_allow_html=True)

# D√©finition des documents RH standard
DOCUMENTS_RH = [
    "Curriculum vitae actualis√©",
    "3 copies certifi√©es conformes des dipl√¥mes obtenus et/ou des certificats de scolarit√©",
    "Copie certifi√©e conforme des certificats de travail des employeurs pr√©c√©dents",
    "3 derniers bulletins de paie d√©livr√©s par l'employeur pr√©c√©dent",
    "Certificat de r√©sidence datant d'au moins 3 mois",
    "Copie certifi√©e conforme de votre C.I.N.",
    "Extrait d'acte de naissance en fran√ßais",
    "Copie de la carte C.N.S.S (ou copie de la C.I.N + 2 photos d'identit√© r√©centes)",
    "Fiche anthropom√©trique originale datant d'au moins 3 mois",
    "2 photos d'identit√© identique datant d'au moins 3 mois (Format standard)",
    "Copie du permis de conduire",
    "Relev√© d'Identit√© Bancaire (RIB) comportant les 24 chiffres",
    "Copie certifi√©e conforme de l'acte de mariage",
    "Copie de la CIN du conjoint",
    "Extrait d'acte de naissance de chaque enfant",
    "Fiche de renseignement d√ªment remplie et sign√©e par le salari√©",
    "Contrat de travail en double exemplaire √† signer et √† l√©galiser",
    "Check-list d'int√©gration sign√©e par votre N+1/tuteur/la DSI et la DQHSE",
    "Annexes du code de bonne conduite sign√©es par vos soins",
    "Photo au format digital, 600*600 pixels sur fond blanc",
    "R√©capitulatif de carri√®re CNSS (t√©l√©chargeable sur l'application MACNSS)"
]

# -------------------- FONCTIONS D'AUTHENTIFICATION GOOGLE --------------------
def get_google_credentials():
    """Cr√©e les identifiants √† partir des secrets Streamlit."""
    try:
        service_account_info = {
            "type": st.secrets["GCP_TYPE"],
            "project_id": st.secrets["GCP_PROJECT_ID"],
            "private_key_id": st.secrets.get("GCP_PRIVATE_KEY_ID", ""),
            "private_key": st.secrets["GCP_PRIVATE_KEY"].replace('\\n', '\n'),
            "client_email": st.secrets["GCP_CLIENT_EMAIL"],
            "client_id": st.secrets.get("GCP_CLIENT_ID", ""),
            "auth_uri": st.secrets.get("GCP_AUTH_URI", "https://accounts.google.com/o/oauth2/auth"),
            "token_uri": st.secrets["GCP_TOKEN_URI"],
            "auth_provider_x509_cert_url": st.secrets.get("GCP_AUTH_PROVIDER_CERT_URL", "https://www.googleapis.com/oauth2/v1/certs"),
            "client_x509_cert_url": st.secrets.get("GCP_CLIENT_CERT_URL", "")
        }
        return service_account.Credentials.from_service_account_info(service_account_info)
    except Exception as e:
        st.error(f"‚ùå Erreur de format des secrets Google: {e}")
        return None

def get_gsheet_client():
    """Authentification pour Google Sheets."""
    try:
        creds = get_google_credentials()
        if creds:
            scoped_creds = creds.with_scopes([
                "https://www.googleapis.com/auth/spreadsheets",
                "https://www.googleapis.com/auth/drive.readonly",
            ])
            gc = gspread.Client(auth=scoped_creds)
            return gc
    except Exception as e:
        st.error(f"‚ùå Erreur d'authentification Google Sheets: {str(e)}")
    return None

# -------------------- FONCTIONS GOOGLE SHEETS --------------------
@st.cache_data(ttl=60)  # Cache pendant 1 minute
def load_data_from_gsheet():
    """Charge les donn√©es depuis Google Sheets"""
    try:
        gc = get_gsheet_client()
        if not gc:
            return pd.DataFrame()
        
        sheet = gc.open_by_url(GOOGLE_SHEET_URL).worksheet(WORKSHEET_NAME)
        data = sheet.get_all_records()
        
        if not data:
            # Cr√©er les en-t√™tes si la feuille est vide
            headers = ['Nom', 'Pr√©nom', 'Poste', 'Service', 'Email', 'Date_integration', 
                      'Documents_manquants', 'Statut', 'Derniere_relance', 'Nombre_relances',
                      'Date_creation', 'Date_modification']
            sheet.clear()
            sheet.append_row(headers)
            return pd.DataFrame(columns=headers)
        
        df = pd.DataFrame(data)
        return df
    except Exception as e:
        st.error(f"‚ùå Erreur lors du chargement des donn√©es Google Sheets: {e}")
        return pd.DataFrame()

def save_data_to_gsheet(df):
    """Sauvegarde les donn√©es dans Google Sheets"""
    try:
        gc = get_gsheet_client()
        if not gc:
            return False
        
        sheet = gc.open_by_url(GOOGLE_SHEET_URL).worksheet(WORKSHEET_NAME)
        
        # Vider la feuille et r√©√©crire toutes les donn√©es
        sheet.clear()
        
        # Ajouter les en-t√™tes
        headers = list(df.columns)
        sheet.append_row(headers)
        
        # Ajouter les donn√©es
        if len(df) > 0:
            values = df.fillna('').values.tolist()
            sheet.append_rows(values)
        
        return True
    except Exception as e:
        st.error(f"‚ùå Erreur lors de la sauvegarde Google Sheets: {e}")
        return False

def add_row_to_gsheet(new_row_data):
    """Ajoute une nouvelle ligne √† Google Sheets"""
    try:
        gc = get_gsheet_client()
        if not gc:
            return False
        
        sheet = gc.open_by_url(GOOGLE_SHEET_URL).worksheet(WORKSHEET_NAME)
        sheet.append_row(new_row_data)
        return True
    except Exception as e:
        st.error(f"‚ùå Erreur lors de l'ajout de ligne Google Sheets: {e}")
        return False

def update_row_in_gsheet(row_index, updated_data):
    """Met √† jour une ligne sp√©cifique dans Google Sheets"""
    try:
        gc = get_gsheet_client()
        if not gc:
            return False
        
        sheet = gc.open_by_url(GOOGLE_SHEET_URL).worksheet(WORKSHEET_NAME)
        
        # row_index + 2 car : +1 pour l'index Python (0-based) vers Google Sheets (1-based), +1 pour ignorer l'en-t√™te
        for col_idx, value in enumerate(updated_data, start=1):
            # Convertir les valeurs NaN en cha√Ænes vides
            cell_value = '' if pd.isna(value) else str(value)
            sheet.update_cell(row_index + 2, col_idx, cell_value)
        
        return True
    except Exception as e:
        # Log l'erreur sans afficher le message transitoire
        print(f"Erreur Google Sheets (masqu√©e): {e}")
        return False

# Initialisation des donn√©es en session
if 'hr_database' not in st.session_state:
    st.session_state.hr_database = load_data_from_gsheet()

if 'relance_history' not in st.session_state:
    st.session_state.relance_history = pd.DataFrame(columns=[
        'Date', 'Collaborateur', 'Email', 'Documents_relances', 'Statut_envoi'
    ])

if 'scheduled_relances' not in st.session_state:
    st.session_state.scheduled_relances = pd.DataFrame(columns=[
        'Date_programmee', 'Collaborateur', 'Email', 'Documents_relances', 'Date_limite', 'Statut'
    ])

# Fonctions utilitaires
def save_data():
    """Sauvegarde les donn√©es dans Google Sheets"""
    return save_data_to_gsheet(st.session_state.hr_database)

def load_data():
    """Recharge les donn√©es depuis Google Sheets"""
    try:
        st.session_state.hr_database = load_data_from_gsheet()
        return True
    except Exception as e:
        st.error(f"Erreur lors du rechargement: {e}")
        return False

def calculate_completion_percentage():
    """Calcule le pourcentage de dossiers complets"""
    if len(st.session_state.hr_database) == 0:
        return 0
    complete_count = len(st.session_state.hr_database[st.session_state.hr_database['Statut'] == 'Complet'])
    return (complete_count / len(st.session_state.hr_database)) * 100

def get_missing_documents_count(documents_json):
    """Compte le nombre de documents manquants"""
    try:
        docs = json.loads(documents_json)
        return len(docs)
    except:
        return 0

def send_email_reminder(recipient_email, recipient_name, missing_docs, delay_date=None, custom_body=None):
    """Envoie un email de relance via SMTP"""
    try:
        # Configuration SMTP - utiliser les secrets Streamlit
        smtp_server = st.secrets.get("SMTP_SERVER", "smtp.gmail.com")
        smtp_port = int(st.secrets.get("SMTP_PORT", 587))
        sender_email = st.secrets.get("SENDER_EMAIL", "")
        sender_password = st.secrets.get("SENDER_PASSWORD", "")
        
        if not sender_email or not sender_password:
            st.error("‚ùå Configuration email manquante. Veuillez configurer SENDER_EMAIL et SENDER_PASSWORD dans les secrets.")
            return False
        
        # Utiliser le corps personnalis√© s'il est fourni, sinon utiliser le template par d√©faut
        if custom_body:
            body = custom_body
        else:
            # Cr√©er le corps du message avec le template par d√©faut
            docs_list = '\n'.join([f"‚Ä¢ {doc}" for doc in missing_docs])
            
            body = f"""Bonjour {recipient_name},

Merci de noter que votre dossier administratif RH demeure incomplet √† ce jour.
Merci de remettre les √©l√©ments suivants afin de le compl√©ter:

{docs_list}

Les documents doivent √™tre envoy√©s via le pointeur chantier dans une enveloppe ferm√©e, en mentionnant CONFIDENTIEL et A L'ATTENTION DE M.L'EQUIPE RECRUTEMENT.

Merci de noter que le dernier d√©lai pour compl√©ter votre dossier c'est le {delay_date if delay_date else (datetime.now() + timedelta(days=14)).strftime('%d/%m/%Y')}

Comptant sur votre pr√©cieuse collaboration.

Cordialement"""
        
        # Cr√©er le message
        message = MIMEMultipart()
        message['From'] = sender_email
        message['To'] = recipient_email
        message['Subject'] = "URGENT: Compl√©ment du dossier administrative RH"
        message.attach(MIMEText(body, 'plain', 'utf-8'))
        
        # Envoyer l'email via SMTP
        with smtplib.SMTP(smtp_server, smtp_port) as server:
            server.starttls()  # Activer la s√©curit√©
            server.login(sender_email, sender_password)
            server.send_message(message)
        
        return True
    except Exception as e:
        st.error(f"Erreur lors de l'envoi de l'email via SMTP: {e}")
        return False

# Titre principal
st.markdown('<h1 class="main-header">üìã Suivi des Dossiers RH</h1>', unsafe_allow_html=True)
st.markdown("---")

# Cr√©er les onglets
tab1, tab2, tab3 = st.tabs([
    "üìä Suivi Global",
    "üë§ Gestion Collaborateur", 
    "üìß Relances Automatiques"
])

# ============================
# ONGLET 1: SUIVI GLOBAL
# ============================
with tab1:
    st.header("üìä Vue d'ensemble des dossiers RH")
    
    # M√©triques principales
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        total_collaborateurs = len(st.session_state.hr_database)
        st.metric("üë• Total Collaborateurs", total_collaborateurs)
    
    with col2:
        complete_count = len(st.session_state.hr_database[st.session_state.hr_database['Statut'] == 'Complet'])
        st.metric("‚úÖ Dossiers Complets", complete_count)
    
    with col3:
        incomplete_count = total_collaborateurs - complete_count
        st.metric("‚è≥ Dossiers En Cours", incomplete_count)
    
    with col4:
        completion_rate = calculate_completion_percentage()
        st.metric("üìà Taux de Compl√©tude", f"{completion_rate:.1f}%")
    
    # Barre de progression globale
    st.subheader("üéØ Progression Globale")
    progress_bar = st.progress(completion_rate / 100)
    st.write(f"**{completion_rate:.1f}%** des dossiers sont complets")
    
    # Graphiques
    col_chart1, col_chart2 = st.columns(2)
    
    with col_chart1:
        # Graphique en secteurs - R√©partition des statuts
        status_counts = st.session_state.hr_database['Statut'].value_counts()
        fig_pie = px.pie(
            values=status_counts.values, 
            names=status_counts.index,
            title="R√©partition des Statuts",
            color_discrete_map={'Complet': '#28a745', 'En cours': '#ffc107'}
        )
        st.plotly_chart(fig_pie, use_container_width=True)
    
    with col_chart2:
        # Graphique en barres - Par service
        service_stats = st.session_state.hr_database.groupby(['Service', 'Statut']).size().unstack(fill_value=0)

        # Guard: si aucune donn√©e disponible
        if service_stats.empty:
            st.info("Aucune donn√©e par service disponible pour l'instant.")
        else:
            df_service = service_stats.reset_index()
            # D√©terminer les colonnes y disponibles (√©vite ShapeError si une colonne manque)
            desired_cols = ['Complet', 'En cours']
            y_cols = [c for c in desired_cols if c in service_stats.columns]

            if not y_cols:
                st.info("Aucune colonne de statut standard ('Complet'/'En cours') trouv√©e pour les services.")
            else:
                try:
                    fig_bar = px.bar(
                        df_service,
                        x='Service',
                        y=y_cols,
                        title="Statuts par Service",
                        color_discrete_map={'Complet': '#28a745', 'En cours': '#ffc107'}
                    )
                    st.plotly_chart(fig_bar, use_container_width=True)
                except Exception as e:
                    st.error(f"Erreur affichage graphique par service: {e}")
    
    st.markdown("---")
    
    # Filtres
    st.subheader("üîç Filtres")
    col_filter1, col_filter2, col_filter3, col_filter4 = st.columns(4)
    
    with col_filter1:
        status_filter = st.selectbox("Filtrer par Statut", ["Tous", "Complet", "En cours"])
    
    with col_filter2:
        services = ["Tous"] + list(st.session_state.hr_database['Service'].unique())
        service_filter = st.selectbox("Filtrer par Service", services)
    
    with col_filter3:
        relance_filter = st.selectbox("Filtrer par Relances", ["Toutes", "0 relance", "1 relance", "2+ relances"])
    
    with col_filter4:
        sort_by = st.selectbox("Trier par", [
            "Nom", "Date d'int√©gration", "Nombre de documents manquants", "Derni√®re relance"
        ])
    
    # Application des filtres
    filtered_df = st.session_state.hr_database.copy()
    
    if status_filter != "Tous":
        filtered_df = filtered_df[filtered_df['Statut'] == status_filter]
    
    if service_filter != "Tous":
        filtered_df = filtered_df[filtered_df['Service'] == service_filter]
    
    if relance_filter != "Toutes":
        if relance_filter == "0 relance":
            filtered_df = filtered_df[filtered_df['Nombre_relances'] == 0]
        elif relance_filter == "1 relance":
            filtered_df = filtered_df[filtered_df['Nombre_relances'] == 1]
        elif relance_filter == "2+ relances":
            filtered_df = filtered_df[filtered_df['Nombre_relances'] >= 2]
    
    # Ajouter le nombre de documents manquants pour l'affichage
    filtered_df['Nb_docs_manquants'] = filtered_df['Documents_manquants'].apply(get_missing_documents_count)
    
    # Tableau principal
    st.subheader("üìã Liste des Collaborateurs")
    
    if len(filtered_df) > 0:
        # Pr√©parer les donn√©es pour l'affichage
        display_df = filtered_df[['Nom', 'Pr√©nom', 'Poste', 'Service', 'Email', 
                                 'Date_integration', 'Statut', 'Nb_docs_manquants', 
                                 'Derniere_relance', 'Nombre_relances']].copy()
        
        display_df.columns = ['Nom', 'Pr√©nom', 'Poste', 'Service', 'Email', 
                             'Date Int√©gration', 'Statut', 'Docs Manquants', 
                             'Derni√®re Relance', 'Nb Relances']
        
        # Affichage avec formatage conditionnel
        st.dataframe(
            display_df,
            use_container_width=True,
            hide_index=True
        )
        
        # D√©tails des documents manquants
        with st.expander("üìÑ D√©tail des documents manquants"):
            for idx, row in filtered_df.iterrows():
                if row['Statut'] == 'En cours':
                    try:
                        missing_docs = json.loads(row['Documents_manquants'])
                        if missing_docs:
                            st.write(f"**{row['Pr√©nom']} {row['Nom']}** ({row['Poste']}):")
                            for doc in missing_docs:
                                st.write(f"  ‚Ä¢ {doc}")
                            st.write("")
                    except:
                        pass
    else:
        st.info("Aucun collaborateur ne correspond aux filtres s√©lectionn√©s.")
    
    # Boutons d'action
    col_action1, col_action2 = st.columns(2)
    
    with col_action1:
        if st.button("üíæ Sauvegarder dans Google Sheets", use_container_width=True):
            with st.spinner("Sauvegarde en cours..."):
                if save_data():
                    st.success("‚úÖ Donn√©es sauvegard√©es dans Google Sheets!")
                    # Vider le cache pour forcer le rechargement
                    st.cache_data.clear()
    
    with col_action2:
        if st.button("ÔøΩ Recharger depuis Google Sheets", use_container_width=True):
            with st.spinner("Rechargement en cours..."):
                # Vider le cache pour forcer le rechargement
                st.cache_data.clear()
                if load_data():
                    st.success("‚úÖ Donn√©es recharg√©es depuis Google Sheets!")
                    st.rerun()

# ============================
# ONGLET 2: GESTION COLLABORATEUR
# ============================
with tab2:
    st.header("üë§ Ajout / Mise √† jour d'un Collaborateur")
    
    # Choix: Nouveau collaborateur ou mise √† jour
    action_type = st.radio(
        "Que souhaitez-vous faire ?",
        ["‚ûï Ajouter un nouveau collaborateur", "‚úèÔ∏è Mettre √† jour un collaborateur existant"],
        horizontal=True
    )
    
    if action_type == "‚ûï Ajouter un nouveau collaborateur":
        # Formulaire pour nouveau collaborateur
        with st.form("nouveau_collaborateur"):
            st.subheader("üìù Informations du nouveau collaborateur")
            
            col_info1, col_info2 = st.columns(2)
            
            with col_info1:
                nom = st.text_input("Nom *", placeholder="Ex: ALAMI")
                prenom = st.text_input("Pr√©nom *", placeholder="Ex: Ahmed")
                email = st.text_input("Email *", placeholder="Ex: ahmed.alami@tgcc.ma")
            
            with col_info2:
                poste = st.text_input("Poste *", placeholder="Ex: Ing√©nieur IT")
                affectation = st.text_input("Affectation *", placeholder="Ex: Service IT")
                date_integration = st.date_input("Date d'int√©gration")
            
            st.subheader("üìã Documents RH - Cochez les documents FOURNIS")
            st.info("‚ÑπÔ∏è Cochez uniquement les documents que le collaborateur a D√âJ√Ä fournis")
            
            # Checklist des documents
            provided_docs = []
            for i, doc in enumerate(DOCUMENTS_RH):
                if st.checkbox(f"{doc}", key=f"new_{i}"):
                    provided_docs.append(doc)
            
            # Calculer les documents manquants (ceux non coch√©s)
            missing_docs = [doc for doc in DOCUMENTS_RH if doc not in provided_docs]
            
            # Bouton de soumission
            submitted = st.form_submit_button("‚ûï Ajouter le collaborateur", type="primary", use_container_width=True)
            
            if submitted:
                if nom and prenom and email and poste and affectation:
                    # D√©terminer le statut
                    statut = "Complet" if len(missing_docs) == 0 else "En cours"
                    
                    # Timestamps
                    now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                    
                    # Cr√©er la nouvelle entr√©e
                    nouvelle_ligne = pd.DataFrame({
                        'Nom': [nom.upper()],
                        'Pr√©nom': [prenom.title()],
                        'Poste': [poste],
                        'Service': [affectation],
                        'Email': [email.lower()],
                        'Date_integration': [str(date_integration)],
                        'Documents_manquants': [json.dumps(missing_docs)],
                        'Statut': [statut],
                        'Derniere_relance': [''],
                        'Nombre_relances': [0],
                        'Date_creation': [now],
                        'Date_modification': [now]
                    })
                    
                    # Ajouter √† la base de donn√©es locale
                    st.session_state.hr_database = pd.concat([st.session_state.hr_database, nouvelle_ligne], ignore_index=True)
                    
                    # Ajouter directement √† Google Sheets
                    new_row_data = [
                        nom.upper(), prenom.title(), poste, affectation, email.lower(),
                        str(date_integration), json.dumps(missing_docs), statut,
                        '', 0, now, now
                    ]
                    
                    with st.spinner("Ajout √† Google Sheets..."):
                        if add_row_to_gsheet(new_row_data):
                            st.success(f"‚úÖ {prenom} {nom} ajout√©(e) dans Google Sheets!")
                            # Vider le cache pour forcer le rechargement
                            st.cache_data.clear()
                        else:
                            st.warning("‚ö†Ô∏è Ajout√© localement, mais erreur Google Sheets. Utilisez 'Sauvegarder' manuellement.")
                    
                    st.success(f"üìä Statut: **{statut}** ({len(missing_docs)} documents manquants)")
                    
                    if len(missing_docs) > 0:
                        st.info("üìÑ Documents manquants:")
                        for doc in missing_docs:
                            st.write(f"  ‚Ä¢ {doc}")
                    
                    st.rerun()
                else:
                    st.error("‚ùå Veuillez remplir tous les champs obligatoires (*)")
    
    else:
        # Mise √† jour d'un collaborateur existant
        st.subheader("‚úèÔ∏è Mise √† jour d'un collaborateur")
        
        if len(st.session_state.hr_database) > 0:
            # S√©lection du collaborateur
            collaborateurs = st.session_state.hr_database.apply(lambda x: f"{x['Pr√©nom']} {x['Nom']} ({x['Poste']})", axis=1).tolist()
            selected_collab = st.selectbox("Choisir le collaborateur √† mettre √† jour:", collaborateurs)
            
            if selected_collab:
                # Trouver l'index du collaborateur s√©lectionn√©
                selected_idx = collaborateurs.index(selected_collab)
                collab_data = st.session_state.hr_database.iloc[selected_idx]
                
                st.info(f"üìä Statut actuel: **{collab_data['Statut']}**")
                
                # Afficher les documents actuellement manquants
                try:
                    current_missing = json.loads(collab_data['Documents_manquants'])
                except:
                    current_missing = []
                
                if current_missing:
                    st.warning(f"üìÑ Documents actuellement manquants ({len(current_missing)}):")
                    for doc in current_missing:
                        st.write(f"  ‚Ä¢ {doc}")
                else:
                    st.success("‚úÖ Dossier complet - Aucun document manquant!")
                
                # Formulaire de mise √† jour
                with st.form("mise_a_jour"):
                    st.subheader("üìã Mise √† jour des documents fournis")
                    st.info("‚ÑπÔ∏è Cochez les documents qui ont √©t√© FOURNIS")
                    
                    # Checklist avec √©tat actuel (inverse de la logique pr√©c√©dente)
                    provided_docs = []
                    for i, doc in enumerate(DOCUMENTS_RH):
                        is_currently_provided = doc not in current_missing  # Inverse de la logique
                        if st.checkbox(f"{doc}", value=is_currently_provided, key=f"update_{i}"):
                            provided_docs.append(doc)
                    
                    # Calculer les documents manquants (ceux non coch√©s)
                    new_missing_docs = [doc for doc in DOCUMENTS_RH if doc not in provided_docs]
                    
                    # Bouton de mise √† jour
                    update_submitted = st.form_submit_button("üîÑ Mettre √† jour", type="primary", use_container_width=True)
                    
                    if update_submitted:
                        # D√©terminer le nouveau statut
                        nouveau_statut = "Complet" if len(new_missing_docs) == 0 else "En cours"
                        
                        # Timestamp de modification
                        now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                        
                        # Mettre √† jour la base de donn√©es locale
                        st.session_state.hr_database.loc[selected_idx, 'Documents_manquants'] = json.dumps(new_missing_docs)
                        st.session_state.hr_database.loc[selected_idx, 'Statut'] = nouveau_statut
                        st.session_state.hr_database.loc[selected_idx, 'Date_modification'] = now
                        
                        # Mettre √† jour Google Sheets
                        updated_row = st.session_state.hr_database.iloc[selected_idx].fillna('').tolist()
                        
                        with st.spinner("Mise √† jour dans Google Sheets..."):
                            if update_row_in_gsheet(selected_idx, updated_row):
                                st.success("‚úÖ Mis √† jour dans Google Sheets!")
                                # Vider le cache pour forcer le rechargement
                                st.cache_data.clear()
                            else:
                                st.warning("‚ö†Ô∏è Mis √† jour localement, mais erreur Google Sheets. Utilisez 'Sauvegarder' manuellement.")
                        
                        # Afficher le r√©sultat
                        if nouveau_statut == "Complet":
                            st.success(f"üéâ F√©licitations! Le dossier de {collab_data['Pr√©nom']} {collab_data['Nom']} est maintenant COMPLET!")
                        else:
                            st.info(f"üìä Dossier mis √† jour. Statut: **{nouveau_statut}** ({len(new_missing_docs)} documents encore manquants)")
                            if new_missing_docs:
                                st.write("üìÑ Documents encore manquants:")
                                for doc in new_missing_docs:
                                    st.write(f"  ‚Ä¢ {doc}")
                        
                        st.rerun()
        else:
            st.info("üì≠ Aucun collaborateur dans la base de donn√©es. Ajoutez d'abord un collaborateur.")

# ============================
# ONGLET 3: RELANCES AUTOMATIQUES
# ============================
with tab3:
    st.header("üìß Syst√®me de Relances Automatiques")
    
    # Configuration SMTP
    st.info("üìß **Configuration SMTP** : Les emails sont envoy√©s via SMTP. Assurez-vous que SENDER_EMAIL et SENDER_PASSWORD sont configur√©s dans les secrets.")
    
    # S√©lection des collaborateurs √† relancer
    st.subheader("üë• Collaborateurs avec documents manquants")
    
    # Filtrer les collaborateurs avec des documents manquants
    incomplete_collabs = st.session_state.hr_database[st.session_state.hr_database['Statut'] == 'En cours'].copy()
    
    if len(incomplete_collabs) > 0:
        # Tableau des collaborateurs √† relancer
        display_incomplete = incomplete_collabs[['Nom', 'Pr√©nom', 'Poste', 'Email', 'Date_integration', 'Derniere_relance', 'Nombre_relances']].copy()
        display_incomplete['Nb_docs_manquants'] = incomplete_collabs['Documents_manquants'].apply(get_missing_documents_count)
        
        display_incomplete.columns = ['Nom', 'Pr√©nom', 'Poste', 'Email', 'Date Int√©gration', 'Derni√®re Relance', 'Nb Relances', 'Docs Manquants']
        
        st.dataframe(display_incomplete, use_container_width=True, hide_index=True)
        
        # Formulaire de relance
        st.subheader("üì® Envoyer une relance")
        
        # S√©lection du collaborateur (en dehors du formulaire pour actualisation dynamique)
        collab_options = incomplete_collabs.apply(lambda x: f"{x['Pr√©nom']} {x['Nom']} ({x['Email']})", axis=1).tolist()
        selected_collab_relance = st.selectbox("Choisir le collaborateur:", collab_options, key="collab_selectbox")
        
        if selected_collab_relance:
            # Trouver les donn√©es du collaborateur s√©lectionn√©
            selected_idx_relance = collab_options.index(selected_collab_relance)
            collab_relance_data = incomplete_collabs.iloc[selected_idx_relance]
            
            # Afficher les documents manquants
            try:
                missing_docs_relance = json.loads(collab_relance_data['Documents_manquants'])
            except:
                missing_docs_relance = []
            
            # Section expandable pour les documents manquants
            with st.expander(f"üìÑ Documents manquants pour {collab_relance_data['Pr√©nom']} {collab_relance_data['Nom']} ({len(missing_docs_relance)} documents)", expanded=True):
                for doc in missing_docs_relance:
                    st.write(f"‚Ä¢ {doc}")
            
            # Calculer les dates selon le type de relance
            delay_date_now = (datetime.now() + timedelta(days=14)).strftime('%d/%m/%Y')
            send_date_1week = (datetime.now() + timedelta(days=7))
            delay_date_1week = (send_date_1week + timedelta(days=14)).strftime('%d/%m/%Y')
            send_date_2weeks = (datetime.now() + timedelta(days=14))
            delay_date_2weeks = (send_date_2weeks + timedelta(days=14)).strftime('%d/%m/%Y')
            
            # Section template email avec possibilit√© d'√©dition
            with st.expander("üìß √âditer le mod√®le d'email", expanded=False):
                docs_list_preview = '\n'.join([f"‚Ä¢ {doc}" for doc in missing_docs_relance])
                
                default_email_body = f"""Bonjour {collab_relance_data['Pr√©nom']},

Merci de noter que votre dossier administratif RH demeure incomplet √† ce jour.
Merci de remettre les √©l√©ments suivants afin de le compl√©ter:

{docs_list_preview}

Les documents doivent √™tre envoy√©s via le pointeur chantier dans une enveloppe ferm√©e, en mentionnant CONFIDENTIEL et A L'ATTENTION DE M.L'EQUIPE RECRUTEMENT.

Merci de noter que le dernier d√©lai pour compl√©ter votre dossier c'est le {delay_date_now}

Comptant sur votre pr√©cieuse collaboration.

Cordialement"""
                
                # Zone de texte √©ditable pour le corps du message
                custom_email_body = st.text_area(
                    "Corps du message (modifiable):",
                    value=default_email_body,
                    height=300,
                    key=f"email_body_{selected_idx_relance}"
                )
                
                st.info("üí° Vous pouvez modifier le texte ci-dessus. La date limite sera automatiquement mise √† jour selon le type de relance choisi.")

            with st.form("relance_form"):
                
                # Options de relance
                st.subheader("‚è∞ Type de relance")
                relance_type = st.radio(
                    "Choisir le type de relance:",
                    ["üìß Envoyer maintenant", "‚è∞ Programmer dans 1 semaine", "‚è∞ Programmer dans 2 semaines"],
                    horizontal=False
                )
                
                # Affichage des informations selon le type de relance
                if relance_type == "üìß Envoyer maintenant":
                    st.info(f"üìÖ Date limite dans l'email: {delay_date_now}")
                    final_delay_date = delay_date_now
                elif relance_type == "‚è∞ Programmer dans 1 semaine":
                    st.info(f"üìß La relance sera envoy√©e le: {send_date_1week.strftime('%d/%m/%Y')}")
                    st.info(f"ÔøΩ Date limite dans l'email: {delay_date_1week}")
                    final_delay_date = delay_date_1week
                else:  # 2 semaines
                    st.info(f"üìß La relance sera envoy√©e le: {send_date_2weeks.strftime('%d/%m/%Y')}")
                    st.info(f"ÔøΩ Date limite dans l'email: {delay_date_2weeks}")
                    final_delay_date = delay_date_2weeks
                
                # Bouton d'envoi
                send_button = st.form_submit_button("üìß Envoyer/Programmer la relance", type="primary", use_container_width=True)
                
                if send_button:
                    with st.spinner("üì§ Traitement de la relance en cours..."):
                        if relance_type == "üìß Envoyer maintenant":
                            # Envoi imm√©diat
                            # Utiliser le corps d'email personnalis√© avec la date limite mise √† jour
                            final_email_body = custom_email_body.replace(delay_date_now, final_delay_date)
                            
                            success = send_email_reminder(
                                collab_relance_data['Email'],
                                collab_relance_data['Pr√©nom'],
                                missing_docs_relance,
                                final_delay_date,
                                final_email_body
                            )
                            
                            if success:
                                # Mettre √† jour les donn√©es de relance
                                original_idx = st.session_state.hr_database[
                                    (st.session_state.hr_database['Nom'] == collab_relance_data['Nom']) &
                                    (st.session_state.hr_database['Pr√©nom'] == collab_relance_data['Pr√©nom'])
                                ].index[0]
                                
                                st.session_state.hr_database.loc[original_idx, 'Derniere_relance'] = datetime.now().strftime('%Y-%m-%d')
                                st.session_state.hr_database.loc[original_idx, 'Nombre_relances'] += 1
                                
                                # Ajouter √† l'historique
                                nouvelle_relance = pd.DataFrame({
                                    'Date': [datetime.now().strftime('%Y-%m-%d %H:%M')],
                                    'Collaborateur': [f"{collab_relance_data['Pr√©nom']} {collab_relance_data['Nom']}"],
                                    'Email': [collab_relance_data['Email']],
                                    'Documents_relances': [json.dumps(missing_docs_relance)],
                                    'Statut_envoi': ['Envoy√© imm√©diatement']
                                })
                                
                                st.session_state.relance_history = pd.concat([st.session_state.relance_history, nouvelle_relance], ignore_index=True)
                                
                                st.success(f"‚úÖ Email envoy√© avec succ√®s √† {collab_relance_data['Pr√©nom']} {collab_relance_data['Nom']}!")
                                st.rerun()
                            else:
                                st.error("‚ùå Erreur lors de l'envoi de l'email via l'API Gmail.")
                        else:
                            # Relance programm√©e
                            if relance_type == "‚è∞ Programmer dans 1 semaine":
                                date_programmee = (datetime.now() + timedelta(days=7)).strftime('%Y-%m-%d %H:%M')
                            else:  # 2 semaines
                                date_programmee = (datetime.now() + timedelta(days=14)).strftime('%Y-%m-%d %H:%M')
                            
                            # Ajouter √† la liste des relances programm√©es
                            relance_programmee = pd.DataFrame({
                                'Date_programmee': [date_programmee],
                                'Collaborateur': [f"{collab_relance_data['Pr√©nom']} {collab_relance_data['Nom']}"],
                                'Email': [collab_relance_data['Email']],
                                'Documents_relances': [json.dumps(missing_docs_relance)],
                                'Date_limite': [final_delay_date],
                                'Statut': ['Programm√©e']
                            })
                            
                            st.session_state.scheduled_relances = pd.concat([st.session_state.scheduled_relances, relance_programmee], ignore_index=True)
                            
                            st.success(f"‚úÖ Relance programm√©e pour le {date_programmee} pour {collab_relance_data['Pr√©nom']} {collab_relance_data['Nom']}!")
                            st.info("üìã La relance sera envoy√©e automatiquement √† la date programm√©e.")
    
    else:
        st.success("üéâ Aucune relance n√©cessaire! Tous les dossiers sont complets.")
    
    # Historique des relances
    st.markdown("---")
    st.subheader("üìà Historique et Programmation des Relances")
    
    # Onglets pour s√©parer l'historique et les relances programm√©es
    hist_tab1, hist_tab2 = st.tabs(["üìß Relances Envoy√©es", "‚è∞ Relances Programm√©es"])
    
    with hist_tab1:
        if len(st.session_state.relance_history) > 0:
            # Affichage de l'historique
            history_display = st.session_state.relance_history.copy()
            history_display = history_display.sort_values('Date', ascending=False)
            
            st.dataframe(history_display, use_container_width=True, hide_index=True)
            
            # Statistiques des relances
            col_stat1, col_stat2, col_stat3 = st.columns(3)
            
            with col_stat1:
                total_relances = len(st.session_state.relance_history)
                st.metric("üìß Total Relances", total_relances)
            
            with col_stat2:
                relances_today = len(st.session_state.relance_history[
                    st.session_state.relance_history['Date'].str.startswith(datetime.now().strftime('%Y-%m-%d'))
                ])
                st.metric("üìÖ Relances Aujourd'hui", relances_today)
            
            with col_stat3:
                avg_relances = st.session_state.hr_database[st.session_state.hr_database['Nombre_relances'] > 0]['Nombre_relances'].mean()
                if pd.notna(avg_relances):
                    st.metric("üìä Moyenne Relances/Collab", f"{avg_relances:.1f}")
                else:
                    st.metric("üìä Moyenne Relances/Collab", "0")
        
        else:
            st.info("üì≠ Aucune relance envoy√©e pour le moment.")
    
    with hist_tab2:
        if len(st.session_state.scheduled_relances) > 0:
            # Affichage des relances programm√©es
            scheduled_display = st.session_state.scheduled_relances.copy()
            scheduled_display = scheduled_display.sort_values('Date_programmee', ascending=True)
            
            st.dataframe(scheduled_display, use_container_width=True, hide_index=True)
            
            # Option pour annuler une relance programm√©e
            if st.button("üóëÔ∏è Supprimer toutes les relances programm√©es", type="secondary"):
                st.session_state.scheduled_relances = pd.DataFrame(columns=[
                    'Date_programmee', 'Collaborateur', 'Email', 'Documents_relances', 'Date_limite', 'Statut'
                ])
                st.success("‚úÖ Toutes les relances programm√©es ont √©t√© supprim√©es.")
                st.rerun()
        else:
            st.info("üìÖ Aucune relance programm√©e pour le moment.")

# Footer
st.markdown("---")
st.markdown("**üíº Syst√®me de Suivi des Dossiers RH - TGCC** | Version 1.0")
